var Config = require('../config');
var StandardDataset = require('./standard-dataset');
var _ = require('underscore');
var Palette = require('../palette');
var Loader = require('../loader');
var Dom = require('../dom');
var ResultHandling = require('../result-handling');
var Gauge = (function () {
    function Gauge(targetElement, gaugeOptions) {
        this._options = this._parseOptions(gaugeOptions);
        this.targetElement = Dom.getElement(targetElement);
        this.loader = new Loader(this.targetElement);
        this._resultHandler = new ResultHandling.ResultHandler();
        this._transitionDuration = {
            none: null,
            some: 300
        };
    }
    Gauge.prototype._parseOptions = function (gaugeOptions) {
        var defaultOptions = {
            transitionOnReload: true,
            fields: {},
            gauge: {},
        }, defaultC3Options = Config.defaultC3Options, options = null, loadsMinMaxFromResult = null, minMaxFromResultsOptions = _.extend(Config.defaultC3Options.minMaxFromResults, defaultC3Options.gauge);
        options = _.extend(defaultOptions, gaugeOptions);
        loadsMinMaxFromResult = _.isString(options.gauge.min + options.gauge.max);
        if (loadsMinMaxFromResult) {
            this._minSelectName = _.isString(options.gauge.min) ? options.gauge.min : null;
            this._maxSelectName = _.isString(options.gauge.max) ? options.gauge.max : null;
            options.gauge = _.extend(options.gauge || {}, minMaxFromResultsOptions);
        }
        else {
            options.gauge = _.extend(options.gauge || {}, defaultC3Options.gauge);
        }
        return options;
    };
    Gauge.prototype._initializeFieldOptions = function (metadata) {
        var fields = metadata.selects.concat(metadata.groups), firstSelect = metadata.selects[0], options = this._options, fieldOptions = options.fields;
        _.each(fields, function (fieldName) {
            fieldOptions[fieldName] = fieldOptions[fieldName] || {};
        });
        options.gauge.label = _.clone(options.gauge.label);
        fieldOptions[firstSelect].valueFormatter = fieldOptions[firstSelect].valueFormatter || options.gauge.label.format;
        options.gauge.label.format = fieldOptions[firstSelect].valueFormatter;
    };
    Gauge.prototype.displayData = function (resultsPromise, metadata, fullReload) {
        if (fullReload === void 0) { fullReload = true; }
        var parsedMetaData = this._parseMetaData(metadata);
        this._initializeFieldOptions(parsedMetaData);
        this._renderGauge(parsedMetaData);
        this._resultHandler.handleResult(resultsPromise, parsedMetaData, this, this._loadData, fullReload);
    };
    Gauge.prototype._parseMetaData = function (metadata) {
        var options = this._options, typeOptions = options.gauge, parsedMetaData = _.clone(metadata), filteredSelected = _.without(metadata.selects, this._minSelectName, this._maxSelectName);
        parsedMetaData.selects = filteredSelected;
        return parsedMetaData;
    };
    Gauge.prototype._loadData = function (results, metadata, fullReload) {
        var options = this._options, typeOptions = options.gauge, resultItems = results.results, dataset = this._buildDataset(resultItems, metadata), keys = dataset.getLabels(), uniqueKeys = _.unique(keys), colors = Palette.getSwatch(uniqueKeys, options.gauge.color ? [options.gauge.color] : null), setMinProperty = this._minSelectName && resultItems.length, setMaxProperty = this._maxSelectName && resultItems.length, minConfigProperty = 'gauge_min', maxConfigProperty = 'gauge_max', showLabelConfigProperty = 'gauge_label_show', internalGaugeConfig = this._gauge.internal.config, transitionDuration = !options.transitionOnReload && fullReload ? this._transitionDuration.none : this._transitionDuration.some;
        internalGaugeConfig.transition_duration = transitionDuration;
        if (setMinProperty) {
            internalGaugeConfig[minConfigProperty] = resultItems[0][this._minSelectName];
            internalGaugeConfig[showLabelConfigProperty] = true;
        }
        if (setMaxProperty) {
            internalGaugeConfig[maxConfigProperty] = resultItems[0][this._maxSelectName];
            internalGaugeConfig[showLabelConfigProperty] = true;
        }
        this._currentDataset = dataset;
        this._gauge.load({
            json: dataset.getData(),
            keys: {
                x: '_x',
                value: keys
            },
            colors: colors
        });
        this._showTitle();
    };
    Gauge.prototype.clear = function () {
        this._rendered = false;
        Dom.removeAllChildren(this.targetElement);
    };
    Gauge.prototype._buildDataset = function (resultItems, metadata) {
        var _this = this;
        var options = this._options, formatters = {
            selectLabelFormatter: function (select) { return options.fields[select] && options.fields[select].label ? options.fields[select].label : select; },
            groupValueFormatter: function (groupByName, groupValue) { return _this._formatGroupValue(groupByName, groupValue); }
        };
        return new StandardDataset(resultItems, metadata, formatters);
    };
    Gauge.prototype._showTitle = function () {
        var options = this._options, titleText = options.title ? options.title.toString() : '', showTitle = titleText.length > 0;
        this._titleElement.textContent = titleText;
        this._titleElement.style.display = !showTitle ? 'none' : '';
    };
    Gauge.prototype._formatValueForLabel = function (label, value) {
        var dataset = this._currentDataset, select = this._currentDataset.getSelect(label), options = this._options, fieldOption = options.fields[select], valueFormatter = fieldOption.valueFormatter;
        if (valueFormatter) {
            return valueFormatter(value);
        }
        return value;
    };
    Gauge.prototype._formatGroupValue = function (groupByName, groupValue) {
        var fieldOption = this._options.fields[groupByName], valueFormatter = fieldOption.valueFormatter;
        if (valueFormatter) {
            return valueFormatter(groupValue);
        }
        return groupValue;
    };
    Gauge.prototype._renderGauge = function (metadata) {
        var _this = this;
        if (this._rendered)
            return;
        var options = this._options, connectGaugeContainer = document.createElement('div'), c3Element = document.createElement('div'), rootElement = this.targetElement, titleElement = document.createElement('span'), timezone = options.timezone || metadata.timezone, dateFormat = null, tooltipValueFormatter = function (value, ratio, id, index) { return _this._formatValueForLabel(id, value); }, config = {
            bindto: c3Element,
            padding: options.gauge.padding,
            data: {
                json: [],
                type: 'gauge'
            },
            transition: {
                duration: this._transitionDuration.none
            },
            tooltip: {
                format: {
                    value: tooltipValueFormatter
                }
            }
        };
        this.clear();
        titleElement.className = 'connect-viz-title';
        c3Element.className = 'connect-viz-result';
        connectGaugeContainer.className = 'connect-viz connect-chart connect-chart-gauge';
        connectGaugeContainer.appendChild(titleElement);
        connectGaugeContainer.appendChild(c3Element);
        rootElement.appendChild(connectGaugeContainer);
        config['gauge'] = options['gauge'];
        this._rendered = true;
        this._titleElement = titleElement;
        this._showTitle();
        this._gauge = c3.generate(config);
    };
    return Gauge;
})();
module.exports = Gauge;
