var Config = require('../config');
var GroupedIntervalDataset = require('./grouped-interval-dataset');
var StandardDataset = require('./standard-dataset');
var _ = require('underscore');
var Palette = require('../palette');
var Loader = require('../loader');
var Formatters = require('../formatters');
var Dom = require('../dom');
var ResultHandling = require('../result-handling');
var Chart = (function () {
    function Chart(targetElement, chartOptions) {
        this._options = this._parseOptions(chartOptions);
        this.targetElement = Dom.getElement(targetElement);
        this.loader = new Loader(this.targetElement);
        this._transitionDuration = {
            none: null,
            some: 300
        };
        this._resultHandler = new ResultHandling.ResultHandler();
    }
    Chart.prototype._parseOptions = function (chartOptions) {
        var defaultOptions = {
            transitionOnReload: true,
            intervals: {},
            fields: {},
            chart: {
                type: 'bar',
                showLegend: true,
                yAxisValueFormatter: function (value) { return value; }
            },
        }, defaultIntervalOptions = {
            formats: Config.defaultTimeSeriesFormats
        }, defaultC3Options = Config.defaultC3Options, options = null, options = _.extend(defaultOptions, chartOptions), type = options.chart.type;
        options.intervals = _.extend(options.intervals, defaultIntervalOptions);
        options[type] = _.extend(options[type] || {}, defaultC3Options[type]);
        return options;
    };
    Chart.prototype._initializeFieldOptions = function (metadata) {
        var fields = metadata.selects.concat(metadata.groups), options = this._options, fieldOptions = options.fields, type = options.chart.type;
        _.each(fields, function (fieldName) {
            fieldOptions[fieldName] = fieldOptions[fieldName] || {};
        });
    };
    Chart.prototype.displayData = function (resultsPromise, metadata, fullReload) {
        if (fullReload === void 0) { fullReload = true; }
        var internalChartConfig;
        this._initializeFieldOptions(metadata);
        this._renderChart(metadata);
        this._resultHandler.handleResult(resultsPromise, metadata, this, this._loadData, fullReload);
    };
    Chart.prototype._loadData = function (results, metadata, fullReload) {
        var options = this._options, type = options.chart.type, resultItems = results.results, typeOptions = options[type], dataset = this._buildDataset(resultItems, metadata), keys = dataset.getLabels(), uniqueKeys = _.unique(keys), colors = Palette.getSwatch(uniqueKeys, options.chart.colors), internalChartConfig = this._chart.internal.config, useTransition = this._chart.data().length && (options.transitionOnReload || !fullReload), transitionDuration = useTransition ? this._transitionDuration.some : this._transitionDuration.none;
        internalChartConfig.transition_duration = transitionDuration;
        this._currentDataset = dataset;
        this._chart.load({
            json: dataset.getData(),
            keys: {
                x: '_x',
                value: keys
            },
            colors: colors
        });
        this._showTitle();
    };
    Chart.prototype.clear = function () {
        this._rendered = false;
        Dom.removeAllChildren(this.targetElement);
    };
    Chart.prototype._buildDataset = function (resultItems, metadata) {
        var _this = this;
        var options = this._options, formatters = {
            selectLabelFormatter: function (select) { return options.fields[select] && options.fields[select].label ? options.fields[select].label : select; },
            groupValueFormatter: function (groupByName, groupValue) { return _this._formatGroupValue(groupByName, groupValue); }
        }, isGroupedInterval = metadata.interval && metadata.groups.length;
        return isGroupedInterval ? new GroupedIntervalDataset(resultItems, metadata, formatters) : new StandardDataset(resultItems, metadata, formatters);
    };
    Chart.prototype._showTitle = function () {
        var options = this._options, titleText = options.title ? options.title.toString() : '', showTitle = titleText.length > 0;
        this._titleElement.textContent = titleText;
        this._titleElement.style.display = !showTitle ? 'none' : '';
    };
    Chart.prototype._formatValueForLabel = function (label, value) {
        var dataset = this._currentDataset, select = this._currentDataset.getSelect(label), options = this._options, fieldOption = options.fields[select], valueFormatter = fieldOption.valueFormatter;
        if (valueFormatter) {
            return valueFormatter(value);
        }
        return value;
    };
    Chart.prototype._formatGroupValue = function (groupByName, groupValue) {
        var fieldOption = this._options.fields[groupByName], valueFormatter = fieldOption.valueFormatter;
        if (valueFormatter) {
            return valueFormatter(groupValue);
        }
        return groupValue;
    };
    Chart.prototype._renderChart = function (metadata) {
        var _this = this;
        if (this._rendered)
            return;
        var options = this._options, connectChartContainer = document.createElement('div'), c3Element = document.createElement('div'), rootElement = this.targetElement, titleElement = document.createElement('span'), timezone = options.timezone || metadata.timezone, dateFormat = null, standardDateformatter = function (value) { return Formatters.formatDate(value, timezone, dateFormat); }, customDateFormatter = options.intervals.valueFormatter, tooltipValueFormatter = function (value, ratio, id, index) { return _this._formatValueForLabel(id, value); }, config = {
            bindto: c3Element,
            size: {
                height: options.chart.height
            },
            padding: options.chart.padding,
            data: {
                json: [],
                type: options.chart.type
            },
            axis: {
                x: {
                    type: 'category',
                    tick: {
                        outer: false,
                        format: undefined
                    }
                },
                y: {
                    tick: {
                        outer: false,
                        format: options.chart.yAxisValueFormatter
                    }
                }
            },
            transition: {
                duration: this._transitionDuration.none
            },
            tooltip: {
                format: {
                    value: tooltipValueFormatter
                }
            },
            legend: {
                show: options.chart.showLegend
            }
        };
        this.clear();
        titleElement.className = 'connect-viz-title';
        c3Element.className = 'connect-viz-result';
        connectChartContainer.className = 'connect-viz connect-chart connect-chart-' + options.chart.type;
        connectChartContainer.appendChild(titleElement);
        connectChartContainer.appendChild(c3Element);
        rootElement.appendChild(connectChartContainer);
        config[options.chart.type] = options[options.chart.type];
        if (metadata.interval) {
            dateFormat = options.intervals.formats[metadata.interval];
            config.data['xFormat'] = '%Y-%m-%dT%H:%M:%SZ';
            config.data['xLocaltime'] = false;
            config.axis.x.type = 'timeseries';
            config.axis.x.tick.format = customDateFormatter || standardDateformatter;
        }
        this._rendered = true;
        this._titleElement = titleElement;
        this._showTitle();
        this._chart = c3.generate(config);
    };
    return Chart;
})();
module.exports = Chart;
