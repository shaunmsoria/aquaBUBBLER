//Adapted from https://github.com/inorganik/countUp.js
var lastTime = 0;
var vendors = ['webkit', 'moz', 'ms', 'o'];
for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
}
if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}
if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
}
var Counter = (function () {
    function Counter(target, duration, valueFormatter) {
        this.target = target;
        this.duration = duration;
        this.valueFormatter = valueFormatter;
    }
    Counter.prototype.printCurrentValue = function () {
        this.target.textContent = this.valueFormatter(this.currentValue);
    };
    Counter.prototype.easeOutExpo = function (t, b, c, d) {
        return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
    };
    Counter.prototype.count = function (timestamp, finished) {
        var _this = this;
        var progress = 0;
        var isFinished = false;
        if (this.startTime == null)
            this.startTime = timestamp;
        this.timestamp = timestamp;
        progress = timestamp - this.startTime;
        this.remaining = this.duration - progress;
        if (this.countDown) {
            var easedValue = this.easeOutExpo(progress, 0, this.startValue - this.endValue, this.duration);
            this.currentValue = this.startValue - easedValue;
        }
        else {
            this.currentValue = this.easeOutExpo(progress, this.startValue, this.endValue - this.startValue, this.duration);
        }
        // don't go past endValue since progress can exceed duration in the last frame
        if (this.countDown) {
            this.currentValue = (this.currentValue < this.endValue) ? this.endValue : this.currentValue;
        }
        else {
            this.currentValue = (this.currentValue > this.endValue) ? this.endValue : this.currentValue;
        }
        this.printCurrentValue();
        isFinished = progress < this.duration;
        if (isFinished) {
            this.animationId = requestAnimationFrame(function (timestamp) { return _this.count(timestamp, finished); });
        }
        else {
            this.animationId = null;
            if (finished)
                finished();
        }
    };
    Counter.prototype.stop = function () {
        if (this.animationId)
            cancelAnimationFrame(this.animationId);
    };
    Counter.prototype.update = function (endValue, finished) {
        var _this = this;
        this.stop();
        this.startTime = null;
        this.startValue = this.endValue || 0;
        this.endValue = endValue;
        this.countDown = (this.startValue > this.endValue) ? true : false;
        this.animationId = requestAnimationFrame(function (timestamp) { return _this.count(timestamp, finished); });
    };
    Counter.prototype.setValue = function (newValue) {
        this.currentValue = newValue;
        this.printCurrentValue();
    };
    return Counter;
})();
module.exports = Counter;
